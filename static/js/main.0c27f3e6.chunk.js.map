{"version":3,"sources":["App.tsx","serviceWorker.ts","index.tsx"],"names":["App","width","height","useState","isPainting","setIsPainting","undefined","mousePosition","setMousePosition","size","setSize","startPaint","useCallback","pointer","coordinates","getCoordinates","mouseEventModifier","event","x","pageX","y","pageY","touchEventModifier","preventDefault","touches","p","canvasRef","current","canvas","offsetLeft","offsetTop","paint","newMousePosition","drawLine","startMousePaint","mouseEvent","pointerEvent","useEffect","addEventListener","removeEventListener","mousePaint","startTouchPaint","touchEvent","from","to","context","getContext","strokeStyle","lineJoin","lineWidth","beginPath","moveTo","lineTo","closePath","stroke","touchPaint","exitPaint","resizeCanvas","ctx","imageData","getImageData","window","innerWidth","innerHeight","putImageData","useRef","ref","defaultProps","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.0c27f3e6.chunk.js","sourcesContent":["import React, { useCallback, useEffect, useRef, useState } from 'react'\n\ntype Coordinate = {\n  x: number\n  y: number\n}\n\ntype Pointer = {\n  x: number\n  y: number\n}\n\nconst getSize = () => {\n  return {\n    width: window.innerWidth,\n    height: window.innerHeight\n  }\n}\n\nconst App = ({ width, height }: { width: number; height: number }) => {\n  const [isPainting, setIsPainting] = useState(false)\n  const [mousePosition, setMousePosition] = useState<Coordinate | undefined>(\n    undefined\n  )\n  const [size, setSize] = useState({ width, height })\n\n  const startPaint = useCallback((pointer: Pointer) => {\n    const coordinates = getCoordinates(pointer)\n    if (coordinates) {\n      setIsPainting(true)\n      setMousePosition(coordinates)\n    }\n  }, [])\n\n  const mouseEventModifier = useCallback((event: MouseEvent) => {\n    const pointer = { x: event.pageX, y: event.pageY }\n    return pointer\n  }, [])\n\n  const touchEventModifier = useCallback((event: TouchEvent) => {\n    event.preventDefault()\n    const pointer = { x: event.touches[0].pageX, y: event.touches[0].pageY }\n    return pointer\n  }, [])\n\n  const getCoordinates = (p: Pointer): Coordinate | undefined => {\n    if (!canvasRef.current) return\n    const canvas: HTMLCanvasElement = canvasRef.current\n    return {\n      x: p.x - canvas.offsetLeft,\n      y: p.y - canvas.offsetTop\n    }\n  }\n\n  const paint = useCallback(\n    (pointer: Pointer) => {\n      if (isPainting) {\n        const newMousePosition = getCoordinates(pointer)\n        if (mousePosition && newMousePosition) {\n          drawLine(mousePosition, newMousePosition)\n          setMousePosition(newMousePosition)\n        }\n      }\n    },\n    [isPainting, mousePosition]\n  )\n\n  const startMousePaint = useCallback(\n    mouseEvent => {\n      const pointerEvent = mouseEventModifier(mouseEvent)\n      startPaint(pointerEvent)\n    },\n    [mouseEventModifier, startPaint]\n  )\n\n  useEffect(() => {\n    if (!canvasRef.current) return\n    const canvas: HTMLCanvasElement = canvasRef.current\n    canvas.addEventListener('mousedown', startMousePaint)\n    return () => {\n      canvas.removeEventListener('mousedown', startMousePaint)\n    }\n  }, [mouseEventModifier, startMousePaint])\n\n  const mousePaint = useCallback(\n    (mouseEvent: MouseEvent) => {\n      const pointerEvent = mouseEventModifier(mouseEvent)\n      paint(pointerEvent)\n    },\n    [mouseEventModifier, paint]\n  )\n\n  const startTouchPaint = useCallback(\n    touchEvent => {\n      const pointerEvent = touchEventModifier(touchEvent)\n      startPaint(pointerEvent)\n    },\n    [startPaint, touchEventModifier]\n  )\n\n  useEffect(() => {\n    if (!canvasRef.current) return\n    const canvas: HTMLCanvasElement = canvasRef.current\n    canvas.addEventListener('touchstart', startTouchPaint)\n    return () => {\n      canvas.removeEventListener('touchstart', startTouchPaint)\n    }\n  }, [startTouchPaint, touchEventModifier])\n\n  const drawLine = (from: Coordinate, to: Coordinate) => {\n    if (!canvasRef.current) return\n    const context = canvasRef.current.getContext('2d')\n    if (context) {\n      context.strokeStyle = 'red'\n      context.lineJoin = 'round'\n      context.lineWidth = 5\n      context.beginPath()\n      context.moveTo(from.x, from.y)\n      context.lineTo(to.x, to.y)\n      context.closePath()\n      context.stroke()\n    }\n  }\n\n  useEffect(() => {\n    if (!canvasRef.current) return\n    const canvas = canvasRef.current\n    canvas.addEventListener('mousemove', mousePaint)\n    return () => {\n      canvas.removeEventListener('mousemove', mousePaint)\n    }\n  }, [mousePaint, paint])\n\n  useEffect(() => {\n    if (!canvasRef.current) return\n    const canvas = canvasRef.current\n    canvas.addEventListener('touchmove', touchPaint)\n    return () => {\n      canvas.removeEventListener('touchmove', touchPaint)\n    }\n  })\n\n  const touchPaint = useCallback(\n    touchEvent => {\n      const pointerEvent = touchEventModifier(touchEvent)\n      paint(pointerEvent)\n    },\n    [paint, touchEventModifier]\n  )\n\n  const exitPaint = useCallback(() => {\n    setIsPainting(false)\n  }, [])\n\n  const resizeCanvas = useCallback(() => {\n    if (!canvasRef.current) return\n    const canvas = canvasRef.current\n    const ctx = canvas.getContext('2d')\n    const imageData = ctx?.getImageData(0, 0, canvas.width, canvas.height)\n    setSize(getSize())\n    if (!imageData) return\n    ctx?.putImageData(imageData, 0, 0)\n  }, [])\n\n  useEffect(() => {\n    if (!canvasRef.current) return\n    const canvas = canvasRef.current\n    canvas.addEventListener('mouseup', exitPaint)\n    canvas.addEventListener('mouseleave', exitPaint)\n    canvas.addEventListener('touched', exitPaint, false)\n    return () => {\n      canvas.removeEventListener('mouseup', exitPaint)\n      canvas.removeEventListener('mouseleave', exitPaint)\n      canvas.removeEventListener('touched', exitPaint)\n    }\n  }, [exitPaint])\n\n  useEffect(() => {\n    if (!canvasRef.current) return\n    window.addEventListener('resize', resizeCanvas)\n    return () => {\n      window.removeEventListener('resize', resizeCanvas)\n    }\n  })\n\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  return (\n    <>\n      <span>\n        height:{size.height} width:{size.width}\n      </span>\n      <canvas ref={canvasRef} height={size.height} width={size.width} />\n    </>\n  )\n}\n\nApp.defaultProps = {\n  width: window.innerWidth,\n  height: window.innerHeight\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport './index.css'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}